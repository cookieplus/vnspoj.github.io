---
layout: post
title:  "DHLOCK - Khóa số"
categories: [brute-force]
code: DHLOCK
src: DHLOCK.cpp
---



  


Bạn nhận được một hộp quà với một khóa số ở bên ngoài. Thông tin hiển thị trên khóa là một dãy _n_ số nguyên _a_1, _a_2,..., _an,_ các số nằm trong phạm vi từ 0 đến _k_. Có (_n_+2) phím dùng để thay đổi giá trị các số, một phím nằm bên trái khóa, một phím nằm bên phải khóa, dưới mỗi số có một phím. Bạn nhanh chóng nhận ra rằng:

\-          Khi bấm vào phím nằm bên trái khóa thì giá trị tất cả các số trên khóa tăng lên 1, nếu số nào đang có giá trị là _k_ thì sau khi bấm nó nhận giá trị 0. Ví dụ, nếu dãy là (10, 9, 0) và _k_ = 10, khi bấm vào phím nằm bên trái khóa thì trạng thái mới của dãy là (0, 10, 1).

\-          Khi bấm vào phím nằm bên phải khóa thì tất cả các số dịch chuyển đi sang bên phải, trừ số cuối cùng, số cuối cùng trở thành số đầu tiên. Ví dụ, nếu dãy là (10, 9, 0) và _k_ = 10, khi bấm vào phím nằm bên phải khóa thì trạng thái mới của dãy là (0, 10, 9).

\-          Khi bấm vào phím nằm bên dưới số thứ _i_ (_i=_1, 2,..., _n_) thì giá trị số thứ _i_ trên khóa tăng lên 1, nếu số đang có giá trị là _k_ thì sau khi bấm nó nhận giá trị 0. Ví dụ, nếu dãy là (10, 9, 0) và _k_ = 10, khi bấm vào phím nằm bên dưới số thứ 2 thì trạng thái mới của dãy là (10, 10, 0).

Trên tờ bưu thiếp gửi kèm chiếc hộp có ghi một dãy _n_ số nguyên _b_1, _b_2,..., _bn_ chính là mật mã để mở được chiếc hộp. Chiếc hộp sẽ được mở nếu thông tin hiển thị trên khóa số là dãy _b_1, _b_2,..., _bn_.

**Yêu cầu:** Cho hai dãy số nguyên _a_1, _a_2,..., _an_, _b_1, _b_2,..., _bn_ và số nguyên dương _k_, hãy tìm cách bấm ít lần nhất để mở được chiếc hộp.

#### Input

\-          Dòng đầu chứa hai số nguyên dương _n, k_;

\-          Dòng thứ hai chứa _n_ số nguyên không âm _a_1, _a_2,..., _an_ (_an_ ≤ _k_);

\-          Dòng thứ ba chứa _n_ số nguyên không âm _b_1, _b_2,..., _bn_ (_bn_ ≤ _k_)

#### Output

Một số nguyên là số lần bấm ít lần nhất để mở được chiếc hộp

#### Example

```
**Input:**

**3 10**

**10 9 0**

**1 0 0**
**Output:**
**3**
```

```

```

```
****Ghi chú:**

*   Có 20% số test ứng với 20% số điểm có _n_ \= 3 và _k_ ≤ 10;
*   Có 40% số test ứng với 40% số điểm có _n_ ≤ 30 và _k_ ≤ 1000;
*   Có 40% số test còn lại ứng với 40% số điểm có _n_ ≤ 300 và _k_ ≤ 10^6** 
```

<!--more-->




Nhận xét đầu tiên là dùng không quá n n-1 lần đẩy sang phải, vì nếu đẩy hơn n-1 lần thì sẽ lặp lại mục tiêu ta dự định đẩy. 

Nhận xét thứ hai chính là nếu đã dùng tăng toàn bộ ít nhất 1 lần thì chắc chắn phải tăng đến một số nào đó trong mã khóa b[], tức là sau khi tăng thì tồn tại
ít nhất một khóa không phải tăng cá nhân nữa :

a1 a2 a3 a4 a5 ... an

giả sử tăng lên d được

c1 c2 c3 c4 c5 ... cn 

khi đó, giả sử tất cả cần phải tăng lên mới được

b1 b2 b3 b4 b5 ... bn 

thì gọi x là min trong các giá trị cần tăng thì ta thực hiện tăng toàn bộ lên x lần thì số bước sẽ nhỏ hơn.


Do đó dựa vào 2 nhận xét trên và N <= 300, ta có một thuật toán O(N^3)
